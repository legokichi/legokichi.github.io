
<h2>
<span id="いちばんシンプルな非同期-rust-のランタイムを自作する" class="fragment"></span><a href="#%E3%81%84%E3%81%A1%E3%81%B0%E3%82%93%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AA%E9%9D%9E%E5%90%8C%E6%9C%9F-rust-%E3%81%AE%E3%83%A9%E3%83%B3%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%92%E8%87%AA%E4%BD%9C%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>いちばんシンプルな非同期 Rust のランタイムを自作する</h2>

<p>基本的な概念の確認のために自作してみました。<br>
簡便化のために select, epoll は使わず、メインスレッドでイベントループ動かし、wakerはmpsc経由で別スレッドから投げます。</p>

<h2>
<span id="タスクを定義する" class="fragment"></span><a href="#%E3%82%BF%E3%82%B9%E3%82%AF%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>タスクを定義する</h2>

<p>タスクとは一連の Future のチェーンです。<br>
<code>Future</code> を <code>spawn</code> するときに発生します。<br>
今回はタスクを <code>Future&lt;Output = ()&gt;</code> のような値を返さないものとして定義しました。</p>

<div class="code-frame" data-lang="rs"><div class="highlight"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="n">Future</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">pin</span><span class="p">::</span><span class="n">Pin</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">,</span> <span class="n">Waker</span><span class="p">};</span>

<span class="c">/// タスクはアウトプットのない BoxFuture</span>
<span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="n">future</span><span class="p">:</span> <span class="n">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'static</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'static</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Self</span> <span class="p">{</span>
            <span class="n">future</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">pin</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c">/// このタスクを poll して Ready を返すと、このタスクは待機キューから削除される</span>
    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">waker</span><span class="p">:</span> <span class="n">Waker</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nn">Context</span><span class="p">::</span><span class="nf">from_waker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waker</span><span class="p">);</span>
        <span class="k">match</span> <span class="nn">Future</span><span class="p">::</span><span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="py">.future</span><span class="nf">.as_mut</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span> <span class="k">=&gt;</span> <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span><span class="p">,</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span> <span class="k">=&gt;</span> <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(()),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div>

<h2>
<span id="waker-と-runtime-イベントループ-を作る" class="fragment"></span><a href="#waker-%E3%81%A8-runtime-%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%AB%E3%83%BC%E3%83%97-%E3%82%92%E4%BD%9C%E3%82%8B"><i class="fa fa-link"></i></a>Waker と Runtime (イベントループ) を作る</h2>

<p>イベントループを作ります。<br>
イベントループの実装に必要なのは 実行可能タスクのキュー と 待機タスクの置き場 、そして 待機タスクの再起動通知を送る Waker です。</p>

<div class="code-frame" data-lang="rs"><div class="highlight"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::{</span><span class="n">Cell</span><span class="p">,</span> <span class="n">RefCell</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BTreeMap</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="n">Future</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">,</span> <span class="n">Waker</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::{</span><span class="n">channel</span><span class="p">,</span> <span class="n">Sender</span><span class="p">,</span> <span class="n">Receiver</span><span class="p">};</span>

<span class="c">// ユニークなタスク ID</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">TaskId</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>

<span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Runtime</span> <span class="p">{</span>
    <span class="n">tx</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">TaskId</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c">/// ユニークなタスク ID を発行するために使う</span>
    <span class="n">task_id_counter</span><span class="p">:</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Cell</span><span class="o">&lt;</span><span class="n">TaskId</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="c">/// 前回 poll したら Pending だったタスクを置いとく場所</span>
    <span class="c">/// タスクがここに入ることを park, ここから出ることを unpark という</span>
    <span class="n">wait_tasks</span><span class="p">:</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">TaskId</span><span class="p">,</span> <span class="n">Task</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="c">/// これから poll するとタスク内の Future が Ready を返し、タスクが１ステップ進むであろうタスクの ID キュー</span>
    <span class="c">/// タスクに対応する Waker が呼ばれると実行可能なタスクがこのキューに突っ込まれる</span>
    <span class="c">/// std::task::Waker が Send + Sync の都合で Arc&lt;Mutex&lt;T&gt;&gt; に包んでいる</span>
    <span class="n">run_queue</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">TaskId</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Runtime</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nf">channel</span><span class="p">();</span>
        <span class="n">Self</span> <span class="p">{</span>
            <span class="n">tx</span><span class="p">,</span>
            <span class="n">task_id_counter</span><span class="p">:</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Cell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
            <span class="n">wait_tasks</span><span class="p">:</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">BTreeMap</span><span class="p">::</span><span class="nf">new</span><span class="p">())),</span>
            <span class="n">run_queue</span><span class="p">:</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">rx</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c">/// タスクを待機タスク置き場に突っ込む</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'static</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">task_id</span> <span class="o">=</span> <span class="k">self</span><span class="py">.task_id_counter</span><span class="nf">.get</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.task_id_counter</span><span class="nf">.set</span><span class="p">(</span><span class="n">task_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">waker</span> <span class="o">=</span> <span class="nn">MpscWaker</span><span class="p">::</span><span class="nf">waker</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="k">self</span><span class="py">.tx</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">task</span> <span class="o">=</span> <span class="nn">Task</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
        <span class="c">// タスクを poll して即時 Ready なら待機タスク置き場には入れない</span>
        <span class="k">match</span> <span class="n">task</span><span class="nf">.poll</span><span class="p">(</span><span class="n">waker</span><span class="p">)</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span> <span class="k">=&gt;</span> <span class="p">{}</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c">// このタスクは待機</span>
                <span class="k">self</span><span class="py">.wait_tasks</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.insert</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c">/// イベントループを起動して Pending なタスクがなくなるで待つ</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'static</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.spawn</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="c">// いわゆる Reactor </span>
            <span class="c">// 本来はここで epoll して実行準備の整ったタスクに対応する waker を呼ぶ (= mpsc に task id を突っ込む)が、今回は実装しない</span>
            <span class="p">();</span>

            <span class="c">// いわゆる Executer - 実行可能タスクを実行する</span>
            <span class="c">// 実行可能タスクIDキューから待機タスクIDを取り出す</span>
            <span class="k">let</span> <span class="n">task_id</span> <span class="o">=</span> <span class="p">{</span> <span class="k">self</span><span class="py">.run_queue</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">}</span><span class="nf">.recv</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">task</span> <span class="o">=</span> <span class="p">{</span>
              <span class="c">// borrow_mut のスコープを制限</span>
              <span class="k">self</span><span class="py">.wait_tasks</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
            <span class="p">};</span>
            <span class="c">// タスクに waker = context を渡して poll する</span>
            <span class="k">let</span> <span class="n">waker</span> <span class="o">=</span> <span class="nn">MpscWaker</span><span class="p">::</span><span class="nf">waker</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="k">self</span><span class="py">.tx</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="k">match</span> <span class="n">task</span><span class="nf">.poll</span><span class="p">(</span><span class="n">waker</span><span class="p">)</span> <span class="p">{</span>
                <span class="c">// タスク内の Future チェーンがすこし進んだが、タスク全体はまだ終了してない、なので待機タスクに追加</span>
                <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.wait_tasks</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.insert</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c">// タスクが完了したので Drop</span>
                <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span> <span class="k">=&gt;</span> <span class="p">{}</span>
            <span class="p">}</span>

            <span class="c">// 待機タスクが空になったらイベントループ終了</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.wait_tasks</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div>

<p>このイベントループは epoll のかわりに Mpsc の受信でスレッドを止めることでビジーループに入るのを防いでいます。</p>

<p>Waker は待機しているタスクを起こす (wake) 性質をもつ構造体です。<br>
この Waker の wake を呼ぶと reactor が反応(react) してイベントループがまわります。<br>
<code>std::task::Waker</code> はなぜかトレイトではなく vtable をもつ構造体として定義されています。<br>
<del>ランタイム作者の最適化の余地を残している？ようです</del><br>
どうやら future は core ライブラリに生え手いて Box、Rc や Arc などのalloc の使えない組み込み向けにも使えるように低レベルの API が露出しているようです</p>

<div class="code-frame" data-lang="rs"><div class="highlight"><pre><span class="k">use</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">ArcWake</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">Waker</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::{</span><span class="n">channel</span><span class="p">,</span> <span class="n">Sender</span><span class="p">,</span> <span class="n">Receiver</span><span class="p">};</span>

<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="nf">MpscWaker</span><span class="p">(</span><span class="n">TaskId</span><span class="p">,</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">TaskId</span><span class="o">&gt;&gt;&gt;</span><span class="p">);</span>
<span class="k">impl</span> <span class="n">MpscWaker</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">waker</span><span class="p">(</span><span class="n">task_id</span><span class="p">:</span> <span class="n">TaskId</span><span class="p">,</span> <span class="n">tx</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">TaskId</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Waker</span> <span class="p">{</span>
        <span class="nn">futures</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">waker</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">MpscWaker</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">tx</span><span class="p">)))))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">ArcWake</span> <span class="k">for</span> <span class="n">MpscWaker</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">wake_by_ref</span><span class="p">(</span><span class="n">arc_self</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">MpscWaker</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="k">ref</span> <span class="n">tx</span><span class="p">)</span> <span class="o">=</span> <span class="o">**</span><span class="n">arc_self</span><span class="p">;</span>
        <span class="n">tx</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.send</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div>

<p>始めは futures ライブラリの <code>futures::task::ArcWake</code> を使わずに std の <code>std::task::{RawWaker, RawWakerVTable, Waker}</code> だけで Waker を作ってみようと思ったのですが、 <code>std::task::Waker</code> は <code>Send + Sync</code> を要求しており、 Rc だけは無理そうだったので、この性質を満たすために素直に <code>futures::task::ArcWake</code> を使うことにしました。<br>
詳細については <a href="https://keens.github.io/blog/2019/07/07/rustnofuturetosonorunnerwotsukuttemita/" rel="nofollow noopener" target="_blank">Keenさんの記事</a> をどうぞ</p>

<h2>
<span id="タイマーを作る" class="fragment"></span><a href="#%E3%82%BF%E3%82%A4%E3%83%9E%E3%83%BC%E3%82%92%E4%BD%9C%E3%82%8B"><i class="fa fa-link"></i></a>タイマーを作る</h2>

<p>今回はごくシンプルにタイマーごとにスレッドを立てて sleep する実装にしました。<br>
スレッドが目覚めたら waker を呼びます。</p>

<div class="code-frame" data-lang="rs"><div class="highlight"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="n">Future</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">pin</span><span class="p">::</span><span class="n">Pin</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">,</span> <span class="n">Waker</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Timeout</span> <span class="p">{</span>
    <span class="c">// タイマースレッドのハンドル</span>
    <span class="n">th</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="c">// タイマーの状態</span>
    <span class="n">state</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">Poll</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="c">// タイマーが発動したときに呼ぶ waker </span>
    <span class="n">waker</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Waker</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Timeout</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="n">Duration</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">waker</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Waker</span><span class="o">&gt;</span><span class="p">));</span>
        <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span><span class="p">));</span>
        <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">waker</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">th</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="c">// スリープ</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
            <span class="c">// state を Ready にする</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(());</span>
            <span class="c">// waker を呼んでこの Future が所属するタスクを実行可能タスクIDキューに積む</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">waker</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">w</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">waker</span><span class="nf">.wake_by_ref</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">});</span>
        <span class="n">Self</span> <span class="p">{</span>
            <span class="n">th</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">th</span><span class="p">),</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="n">waker</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">Timeout</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>
    <span class="c">/// 初回 poll 時の waker を借りパクして流用します</span>
    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">:</span> <span class="n">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="o">*</span><span class="k">self</span><span class="py">.waker</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ctx</span><span class="nf">.waker</span><span class="p">()</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">match</span> <span class="o">*</span><span class="k">self</span><span class="py">.state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span> <span class="k">=&gt;</span> <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span><span class="p">,</span>
            <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span> <span class="k">=&gt;</span> <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(()),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Drop</span> <span class="k">for</span> <span class="n">Timeout</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.th</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div>

<p>スレッドを使わないタイマーを実装するには reactor の部分で 現在待っているタイマーの一覧から最小の待ち時間のものを調べてその時間だけ sleep する必要があります。<br>
async-std の <a href="https://github.com/async-rs/futures-timer" rel="nofollow noopener" target="_blank">futures-timer</a> や初期の tokio-core のタイマーは最小ヒープ木によって次のsleep時間 (実際にはsleep ではなく復帰可能な <a href="https://doc.rust-lang.org/std/thread/fn.park_timeout.html" rel="nofollow noopener" target="_blank">std::thread::park_timeout</a>を使っているよう) を算出しているようです。<br>
また <a href="https://github.com/tokio-rs/tokio-timer#hashed-timing-wheel" rel="nofollow noopener" target="_blank">tokio-timer</a> は Hashed Timing Wheels というより<a href="https://tokio.rs/blog/2018-03-timers/" rel="nofollow noopener" target="_blank">高精度で効率的なタイマーアルゴリズムを使っているよう</a>です。<br>
他にも epoll で使える <a href="https://github.com/polachok/tokio-timerfd" rel="nofollow noopener" target="_blank">timerfd</a> を使った実装などもあるようです。</p>

<p>async-std の futures-timer は内部にシングルトンのタイマースレッドをもっており、ランタイムに依存しないタイマー(tokioでも動く)です。<br>
一方で timerfd や </p>

<h2>
<span id="タイマーを使ってみる" class="fragment"></span><a href="#%E3%82%BF%E3%82%A4%E3%83%9E%E3%83%BC%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%82%8B"><i class="fa fa-link"></i></a>タイマーを使ってみる</h2>

<p>async や spawn や join を駆使した複雑なフローを試してみます。<br>
果たしてうまく動くでしょうか？</p>

<div class="code-frame" data-lang="rs"><div class="highlight"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="n">join</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">runtime</span> <span class="o">=</span> <span class="nn">Runtime</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">runtime</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="n">runtime</span><span class="nf">.run</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start_at</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
        <span class="n">r</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
            <span class="nn">Timeout</span><span class="p">::</span><span class="nf">set</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="py">.await</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"100ms: {}ms"</span><span class="p">,</span> <span class="n">start_at</span><span class="nf">.elasped</span><span class="p">()</span><span class="nf">.as_millis</span><span class="p">());</span>
        <span class="p">});</span>
        <span class="nf">join</span><span class="p">(</span>
            <span class="k">async</span> <span class="p">{</span>
                <span class="nn">Timeout</span><span class="p">::</span><span class="nf">set</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span><span class="py">.await</span><span class="p">;</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"1000ms: {}ms"</span><span class="p">,</span> <span class="n">start_at</span><span class="nf">.elasped</span><span class="p">()</span><span class="nf">.as_millis</span><span class="p">());</span>
                <span class="nn">Timeout</span><span class="p">::</span><span class="nf">set</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">500</span><span class="p">))</span><span class="py">.await</span><span class="p">;</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"1500ms: {}ms"</span><span class="p">,</span> <span class="n">start_at</span><span class="nf">.elasped</span><span class="p">()</span><span class="nf">.as_millis</span><span class="p">());</span>
            <span class="p">},</span>
            <span class="k">async</span> <span class="p">{</span>
                <span class="nn">Timeout</span><span class="p">::</span><span class="nf">set</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">2000</span><span class="p">))</span><span class="py">.await</span><span class="p">;</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"2000ms: {}ms"</span><span class="p">,</span> <span class="n">start_at</span><span class="nf">.elasped</span><span class="p">()</span><span class="nf">.as_millis</span><span class="p">());</span>
            <span class="p">},</span>
        <span class="p">)</span>
        <span class="py">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"joined: {}ms"</span><span class="p">,</span> <span class="n">start_at</span><span class="nf">.elasped</span><span class="p">()</span><span class="nf">.as_millis</span><span class="p">());</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div></div>

<div class="code-frame" data-lang="text"><div class="highlight"><pre>100ms: 102ms
1000ms: 1002ms
1500ms: 1502ms
2000ms: 2002ms
joined: 2002ms
</pre></div></div>

<p>うまく動きました！</p>

<ul>
<li>コード全体 - <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3bfa55aef722898021afe7183ba8cf23" class="autolink" rel="nofollow noopener" target="_blank">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3bfa55aef722898021afe7183ba8cf23</a>
</li>
</ul>

<h2>
<span id="感想" class="fragment"></span><a href="#%E6%84%9F%E6%83%B3"><i class="fa fa-link"></i></a>感想</h2>

<ul>
<li>自作ランタイムが動いて嬉しい！</li>
<li>Context と Waker が妙に冗長なのは何故</li>
<li>ArcWake はあるけど RcWake がないのは何故（あるいは Waker に Send + Sync がついているのは何故）</li>
<li>そのうち wheel timer も作りたい</li>
</ul>

<h2>
<span id="参考" class="fragment"></span><a href="#%E5%8F%82%E8%80%83"><i class="fa fa-link"></i></a>参考</h2>

<ul>
<li><a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html" class="autolink" rel="nofollow noopener" target="_blank">https://rust-lang.github.io/async-book/02_execution/01_chapter.html</a></li>
<li><a href="https://github.com/polachok/fahrenheit" class="autolink" rel="nofollow noopener" target="_blank">https://github.com/polachok/fahrenheit</a></li>
<li>
<a href="https://keens.github.io/blog/2019/07/07/rustnofuturetosonorunnerwotsukuttemita/" class="autolink" rel="nofollow noopener" target="_blank">https://keens.github.io/blog/2019/07/07/rustnofuturetosonorunnerwotsukuttemita/</a> </li>
<li><a href="https://raskr.hatenablog.com/entry/2018/07/16/214420" class="autolink" rel="nofollow noopener" target="_blank">https://raskr.hatenablog.com/entry/2018/07/16/214420</a></li>
</ul>

<h2>
<span id="おまけ-heap-timer-のアルゴリズム" class="fragment"></span><a href="#%E3%81%8A%E3%81%BE%E3%81%91-heap-timer-%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0"><i class="fa fa-link"></i></a>おまけ Heap Timer のアルゴリズム</h2>

<p>futures-timer で使われている min-heap timer のアルゴリズムの最小構成です</p>

<div class="code-frame" data-lang="rs"><div class="highlight"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::{</span><span class="n">Duration</span><span class="p">,</span> <span class="n">Instant</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">;</span>

<span class="nd">#[derive(Copy,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Debug)]</span>
<span class="k">struct</span> <span class="nf">Timeout</span><span class="p">(</span><span class="n">Instant</span><span class="p">);</span>
<span class="k">impl</span> <span class="n">Timeout</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">timeout</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="n">Duration</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="nf">Self</span><span class="p">(</span><span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">duration</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">wait_for</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Duration</span> <span class="p">{</span>
        <span class="k">self</span><span class="err">.</span><span class="mi">0</span> <span class="o">-</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Ord</span> <span class="k">for</span> <span class="n">Timeout</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Timeout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="c">// Rust の BinaryHeap は max-heap だが</span>
        <span class="c">// 使いたいのは min-heap なので</span>
        <span class="c">// 順序を逆にしてる</span>
        <span class="n">other</span><span class="err">.</span><span class="mi">0</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">PartialOrd</span> <span class="k">for</span> <span class="n">Timeout</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Timeout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nn">Ord</span><span class="p">::</span><span class="nf">cmp</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">let</span> <span class="n">now</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">heap</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">heap</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Timeout</span><span class="p">::</span><span class="nf">timeout</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)));</span>
    <span class="n">heap</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Timeout</span><span class="p">::</span><span class="nf">timeout</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">)));</span>
    <span class="n">heap</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Timeout</span><span class="p">::</span><span class="nf">timeout</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">)));</span>

    <span class="k">let</span> <span class="n">th</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||{</span>
        <span class="k">loop</span><span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="o">=</span> <span class="n">heap</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">o</span><span class="p">|</span> <span class="n">o</span><span class="nf">.wait_for</span><span class="p">())</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}ms + {}ms"</span><span class="p">,</span> <span class="n">now</span><span class="nf">.elapsed</span><span class="p">()</span><span class="nf">.as_millis</span><span class="p">(),</span> <span class="n">wait</span><span class="nf">.as_millis</span><span class="p">());</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">park_timeout</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}ms"</span><span class="p">,</span> <span class="n">now</span><span class="nf">.elapsed</span><span class="p">()</span><span class="nf">.as_millis</span><span class="p">());</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="n">th</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div>

<p>出力</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre>0ms + 9ms
10ms
10ms + 89ms
100ms
100ms + 899ms
1000ms
</pre></div></div>

<ul>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ac9e7a53017c08d0ef7592e94db66186" class="autolink" rel="nofollow noopener" target="_blank">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ac9e7a53017c08d0ef7592e94db66186</a></li>
</ul>
