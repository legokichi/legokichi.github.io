
<h1>
<span id="javascript-promise-デザインパターン---reduce-を使った可変長非同期逐次処理--キャンセル可能なpromise-など--" class="fragment"></span><a href="#javascript-promise-%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3---reduce-%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E5%8F%AF%E5%A4%89%E9%95%B7%E9%9D%9E%E5%90%8C%E6%9C%9F%E9%80%90%E6%AC%A1%E5%87%A6%E7%90%86--%E3%82%AD%E3%83%A3%E3%83%B3%E3%82%BB%E3%83%AB%E5%8F%AF%E8%83%BD%E3%81%AApromise-%E3%81%AA%E3%81%A9--"><i class="fa fa-link"></i></a>JavaScript Promise デザインパターン - reduce を使った可変長非同期逐次処理 , キャンセル可能なPromise など -</h1>

<h2>
<span id="promise-の中では-throw-してはならない" class="fragment"></span><a href="#promise-%E3%81%AE%E4%B8%AD%E3%81%A7%E3%81%AF-throw-%E3%81%97%E3%81%A6%E3%81%AF%E3%81%AA%E3%82%89%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>Promise の中では <code>throw</code> してはならない</h2>

<p>このコードは何が表示されるだろうか？</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">a</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">});</span>
</pre></div></div>

<p>答えは <strong>何も起きない</strong> である。</p>

<p>setTimeout の中の関数のような非同期実行コンテキストで throw したエラーはグローバルエラーとなるため<br>
<code>window.onerror</code> や <code>process.on('uncaughtException', (err) =&gt; {})</code> でしか拾うことができない。</p>

<p>代わりに <code>reject</code> を使って</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">a</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">});</span>
</pre></div></div>

<p>のように書かなければならない。</p>

<p>ちなみに <strong>Promise の引数関数 <code>(resolve, reject)=&gt;{}</code> は同期的に実行される</strong> ため、</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span>
<span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">a</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">});</span>
</pre></div></div>

<p>は <code>a</code>, <code>b</code> が表示されてから <code>alert(err)</code> が発生し、問題なくエラーハンドリングできる。</p>

<p>しかし、ややこしいため <strong>Promise の中では throw は使わず必ず reject する</strong> ことを心がけるべきである。</p>

<h2>
<span id="new-promiseresolve---というコードは書かない" class="fragment"></span><a href="#new-promiseresolve---%E3%81%A8%E3%81%84%E3%81%86%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E6%9B%B8%E3%81%8B%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a><code>new Promise(resolve =&gt;{ ... })</code>　というコードは書かない。</h2>

<p><strong><code>new Promise(resolve =&gt;{ ... })</code> というコードを見かけたら要注意である</strong> 。<br>
そのコードはエラーハンドリングがされていない可能性が濃厚だからである。<br>
reject されない Promise はエラーを catch することはできない。デバッグなどほとんど不可能なコードになってしまう。</p>

<p>あなたのリポジトリも <code>git grep "new Promise"</code> で resolve だけPromise がないかチェックしてみよう。</p>

<p>例外的に失敗がありえない非同期処理(例: setTimeoutなど)は resolve だけでも良い。</p>

<h2>
<span id="投げっぱなしの非同期処理はコメントに書いておく" class="fragment"></span><a href="#%E6%8A%95%E3%81%92%E3%81%A3%E3%81%B1%E3%81%AA%E3%81%97%E3%81%AE%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86%E3%81%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%AB%E6%9B%B8%E3%81%84%E3%81%A6%E3%81%8A%E3%81%8F"><i class="fa fa-link"></i></a>投げっぱなしの非同期処理はコメントに書いておく</h2>

<p>処理の失敗を気にせず投げっぱなしの非同期処理を書きたいときもある(例: サーバにテレメトリを定期的に投げる)。</p>

<p>その場合はコメントで <strong>この非同期処理は投げっぱなしであることを明記</strong> すべきである</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="nx">setInterval</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
  <span class="c1">// 定期的にサーバにアクセスして生存報告するがフロント側では特になにもしない</span>
  <span class="nx">post</span><span class="p">(</span><span class="dl">"</span><span class="s2">http://api.foo.com/post</span><span class="dl">"</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span><span class="cm">/* 特に何もしない */</span><span class="p">})</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span><span class="cm">/* うっとうしい */</span><span class="p">});</span>
<span class="p">},</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
</pre></div></div>

<h2>
<span id="catch-した-例外をさらに-reject-したい" class="fragment"></span><a href="#catch-%E3%81%97%E3%81%9F-%E4%BE%8B%E5%A4%96%E3%82%92%E3%81%95%E3%82%89%E3%81%AB-reject-%E3%81%97%E3%81%9F%E3%81%84"><i class="fa fa-link"></i></a>catch した 例外をさらに reject したい</h2>

<p>次のように reject された Promise を catch してエラー理由を表示したい時があります。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">bar</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="p">});</span>
</pre></div></div>

<p>この <code>.catch((err)=&gt;{ console.error(err); })</code> はエラーを表示した後、 <code>Promise&lt;void&gt;</code> を返すので<br>
<code>.then((bar)=&gt;{ console.log(bar); });</code> では <code>undefined</code> と表示してしまいます。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">bar</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="p">});</span>
</pre></div></div>

<p>こういう場合は <code>.catch((err)=&gt;{ console.error(err); return Promise.reject(err); })</code> として catch の中であらためて reject 値を作りましょう</p>

<h2>
<span id="可変長の非同期タスクを逐次実行" class="fragment"></span><a href="#%E5%8F%AF%E5%A4%89%E9%95%B7%E3%81%AE%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%BF%E3%82%B9%E3%82%AF%E3%82%92%E9%80%90%E6%AC%A1%E5%AE%9F%E8%A1%8C"><i class="fa fa-link"></i></a>可変長の非同期タスクを逐次実行</h2>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">runAsyncSerialTasks</span><span class="p">(</span><span class="nx">tasks</span><span class="p">:</span> <span class="p">(()</span><span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">)[]):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="na">prm</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">task</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">prm</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">task</span><span class="p">),</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">void</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
</pre></div></div>

<p>reduce で <code>Promise.resolve(void 0).then(tasks[0]()).then(tasks[1]())...</code> という promise chain を作る。</p>

<h3>
<span id="例-x-www-form-urlencoded-で順番にpost" class="fragment"></span><a href="#%E4%BE%8B-x-www-form-urlencoded-%E3%81%A7%E9%A0%86%E7%95%AA%E3%81%ABpost"><i class="fa fa-link"></i></a>例： <code>x-www-form-urlencoded</code> で順番にPOST</h3>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">toURLEncoded</span><span class="p">(</span><span class="nx">o</span><span class="p">:</span> <span class="p">{[</span><span class="nx">key</span><span class="p">:</span> <span class="nx">string</span><span class="p">]:</span> <span class="nx">string</span><span class="p">}):</span> <span class="nx">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">key</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nx">key</span><span class="o">+</span><span class="dl">"</span><span class="s2">=</span><span class="dl">"</span><span class="o">+</span><span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">o</span><span class="p">[</span><span class="nx">key</span><span class="p">])).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2">&amp;</span><span class="dl">"</span><span class="p">);</span> 
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">urlAndDatas</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://api.example.com/user/create</span><span class="dl">"</span><span class="p">,</span> <span class="na">data</span><span class="p">:</span> <span class="p">{</span><span class="na">hello</span><span class="p">:</span> <span class="dl">"</span><span class="s2">world</span><span class="dl">"</span><span class="p">}}</span>
<span class="p">];</span>
<span class="kd">const</span> <span class="nx">urlAndDataStrs</span> <span class="o">=</span> <span class="nx">urlAndDatas</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span><span class="nx">url</span><span class="p">,</span> <span class="nx">data</span><span class="p">})</span><span class="o">=&gt;</span> <span class="p">({</span><span class="nx">url</span><span class="p">,</span> <span class="na">data</span><span class="p">:</span> <span class="nx">toURLEncoded</span><span class="p">(</span><span class="nx">data</span><span class="p">)}))</span> 
<span class="kd">const</span> <span class="nx">tasks</span> <span class="o">=</span> <span class="nx">urlAndDataStrs</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">data</span> <span class="p">})</span> <span class="o">=&gt;</span>
    <span class="p">()</span> <span class="o">=&gt;</span>
        <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="p">{</span>
            <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
            <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
                <span class="dl">'</span><span class="s1">Accept</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span><span class="p">,</span>
                <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/x-www-form-urlencoded; charset=utf-8</span><span class="dl">'</span>
            <span class="p">},</span>
            <span class="na">body</span><span class="p">:</span> <span class="nx">data</span> <span class="p">}).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="mi">0</span><span class="p">));</span>

<span class="nx">runAsyncSerialTasks</span><span class="p">(</span><span class="nx">tasks</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">finish</span><span class="dl">"</span><span class="p">);</span> <span class="p">})</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">});</span>
</pre></div></div>

<h3>
<span id="例nodejs-で順番にファイルio" class="fragment"></span><a href="#%E4%BE%8Bnodejs-%E3%81%A7%E9%A0%86%E7%95%AA%E3%81%AB%E3%83%95%E3%82%A1%E3%82%A4%E3%83%ABio"><i class="fa fa-link"></i></a>例：node.js で順番にファイルIO</h3>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">runAsyncSerialTasks</span><span class="p">(</span><span class="nx">prmTasks</span><span class="p">:</span> <span class="p">(()</span><span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">)[]):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">prmTasks</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="na">prm</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">task</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">prm</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">task</span><span class="p">),</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">void</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">fs</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">filenameAndContents</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">foo.txt</span><span class="dl">"</span><span class="p">,</span> <span class="na">content</span><span class="p">:</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span> <span class="p">},</span>
    <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bar.txt</span><span class="dl">"</span><span class="p">,</span> <span class="na">content</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span> <span class="p">}</span>
<span class="p">];</span>
<span class="kd">const</span> <span class="nx">tasks</span> <span class="o">=</span> <span class="nx">filenameAndContents</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">content</span> <span class="p">})</span> <span class="o">=&gt;</span>
    <span class="p">()</span> <span class="o">=&gt;</span>
        <span class="k">new</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">fs</span><span class="p">.</span><span class="nx">writeFile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">utf8</span><span class="dl">"</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="k">void</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">})</span>
<span class="p">);</span>
<span class="nx">runAsyncSerialTasks</span><span class="p">(</span><span class="nx">tasks</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">finish</span><span class="dl">"</span><span class="p">);</span> <span class="p">})</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">});</span>
</pre></div></div>

<h3>
<span id="可変長の非同期タスクを逐次実行して結果も取得" class="fragment"></span><a href="#%E5%8F%AF%E5%A4%89%E9%95%B7%E3%81%AE%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%BF%E3%82%B9%E3%82%AF%E3%82%92%E9%80%90%E6%AC%A1%E5%AE%9F%E8%A1%8C%E3%81%97%E3%81%A6%E7%B5%90%E6%9E%9C%E3%82%82%E5%8F%96%E5%BE%97"><i class="fa fa-link"></i></a>可変長の非同期タスクを逐次実行して結果も取得</h3>

<p>Promise の結果も取得した場合。逐次GETや逐次ファイル読み込みなどの場合につかう。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">runAsyncSerialTasks</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">tasks</span><span class="p">:</span> <span class="p">(()</span><span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)[]):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[]</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">prm</span><span class="p">,</span> <span class="nx">task</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">prm</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">lst</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nx">task</span><span class="p">().</span><span class="nx">then</span><span class="p">((</span><span class="nx">ret</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">ret</span><span class="p">))),</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">([]));</span>
<span class="p">}</span>
</pre></div></div>

<p>reduce の中で <code>task().then((ret)=&gt; lst.concat(ret))</code> として結果のリストを構成している。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="nx">runAsyncSerialTasks</span><span class="p">([</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="p">]).</span><span class="nx">then</span><span class="p">((</span><span class="nx">lst</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">lst</span><span class="p">))</span>
</pre></div></div>

<p>結果 <code>[0,1,2]</code> と表示される。</p>

<h3>
<span id="問題点リトライがしたい" class="fragment"></span><a href="#%E5%95%8F%E9%A1%8C%E7%82%B9%E3%83%AA%E3%83%88%E3%83%A9%E3%82%A4%E3%81%8C%E3%81%97%E3%81%9F%E3%81%84"><i class="fa fa-link"></i></a>問題点：リトライがしたい</h3>

<p><code>Promise.resolve(void 0).then(tasks[0]()).then(tasks[1]())...</code> という promise chain ではどれかひとつエラーが起きたときに残りのタスクが強制終了されてしまう。<br>
せめてリトライがしたくなる。</p>

<h2>
<span id="リトライ付きの可変長の非同期タスクを逐次実行" class="fragment"></span><a href="#%E3%83%AA%E3%83%88%E3%83%A9%E3%82%A4%E4%BB%98%E3%81%8D%E3%81%AE%E5%8F%AF%E5%A4%89%E9%95%B7%E3%81%AE%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%BF%E3%82%B9%E3%82%AF%E3%82%92%E9%80%90%E6%AC%A1%E5%AE%9F%E8%A1%8C"><i class="fa fa-link"></i></a>リトライ付きの可変長の非同期タスクを逐次実行</h2>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">runAsyncSerialTasksWithRetry</span><span class="p">(</span><span class="nx">tasks</span><span class="p">:</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">)[],</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="na">prm</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">task</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">prm</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="nx">recur</span><span class="p">(){</span>
          <span class="k">return</span> <span class="nx">task</span><span class="p">().</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">count</span><span class="p">){</span> <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">return</span> <span class="nx">recur</span><span class="p">();</span>
            <span class="p">}</span>
          <span class="p">});</span>
        <span class="p">}),</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">void</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
</pre></div></div>

<p><code>runAsyncSerialTasks</code> 関数の引数にリトライ回数をつけ、reduce の中身を再帰的にリトライするようにした。</p>

<h2>
<span id="逐次実行中の-promise-chain-をキャンセルしたい" class="fragment"></span><a href="#%E9%80%90%E6%AC%A1%E5%AE%9F%E8%A1%8C%E4%B8%AD%E3%81%AE-promise-chain-%E3%82%92%E3%82%AD%E3%83%A3%E3%83%B3%E3%82%BB%E3%83%AB%E3%81%97%E3%81%9F%E3%81%84"><i class="fa fa-link"></i></a>逐次実行中の Promise Chain をキャンセルしたい</h2>

<p>JS の Promise は C# の Task とは違ってキャンセルできない。<br>
そこで <code>reduce</code> の中で task がひとつ終わるごとに次を続けるかどうかを確認する処理を入れる。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">runCancelableAsyncSerialTasks</span><span class="p">(</span><span class="nx">tasks</span><span class="p">:</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">)[]):</span> <span class="p">{</span> <span class="nl">cancel</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">,</span> <span class="nx">promise</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">}</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">ret</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">promise</span><span class="p">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">void</span> <span class="mi">0</span><span class="p">),</span>
        <span class="na">cancel</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">canceled</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">},</span>
        <span class="na">canceled</span><span class="p">:</span> <span class="kc">false</span>
    <span class="p">};</span>
    <span class="nx">ret</span><span class="p">.</span><span class="nx">promise</span> <span class="o">=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">prm</span><span class="p">,</span> <span class="nx">task</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">prm</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">task</span><span class="p">)</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span>
                <span class="nx">ret</span><span class="p">.</span><span class="nx">canceled</span> <span class="p">?</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">canceled</span><span class="dl">"</span><span class="p">))</span>
                             <span class="p">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">,</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">void</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">cancelable</span> <span class="o">=</span> <span class="nx">runCancelableAsyncSerialTasks</span><span class="p">([</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span> <span class="nx">resolve</span><span class="p">();</span> <span class="p">},</span> <span class="mi">1000</span><span class="p">)),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">);</span> <span class="nx">resolve</span><span class="p">();</span> <span class="p">},</span> <span class="mi">1000</span><span class="p">)),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">c</span><span class="dl">"</span><span class="p">);</span> <span class="nx">resolve</span><span class="p">();</span> <span class="p">},</span> <span class="mi">1000</span><span class="p">)),</span>
<span class="p">]);</span>

<span class="nx">cancelable</span><span class="p">.</span><span class="nx">promise</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">finish</span><span class="dl">"</span><span class="p">);</span> <span class="p">})</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">});</span>

<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">cancelable</span><span class="p">.</span><span class="nx">cancel</span><span class="p">();</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">cancel</span><span class="dl">"</span><span class="p">);</span> <span class="p">},</span> <span class="mi">1100</span><span class="p">);</span>
</pre></div></div>

<p>実行結果</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre>a
cancel
b
Error: canceled
    at &lt;anonymous&gt;:11:50
    at &lt;anonymous&gt;
</pre></div></div>

<p>この場合 <code>b</code> の出力待ち中にキャンセルが入るので <code>b</code> が表示されてからキャンセルされる。<br>
すでに実行中の <code>b</code> を止めることはできない。</p>

<p>こうなると非同期 task にもキャンセルを入れたくなってくる。</p>

<h2>
<span id="キャンセル可能な-promise-を作る" class="fragment"></span><a href="#%E3%82%AD%E3%83%A3%E3%83%B3%E3%82%BB%E3%83%AB%E5%8F%AF%E8%83%BD%E3%81%AA-promise-%E3%82%92%E4%BD%9C%E3%82%8B"><i class="fa fa-link"></i></a>キャンセル可能な Promise を作る</h2>

<p>setTimeout を Promise 化する例はよく見られるが、やはり clearTimeout にも対応しつつ Promise で包みたい、ということは多々ある。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="nx">type</span> <span class="nx">CancelablePromise</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="na">promise</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">cancel</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">cancelableSleep</span><span class="p">(</span><span class="nx">ms</span><span class="p">:</span> <span class="nx">number</span><span class="p">):</span> <span class="nx">CancelablePromise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="na">_reject</span><span class="p">:</span> <span class="p">(</span><span class="na">err</span><span class="p">:</span> <span class="nb">Error</span><span class="p">)</span><span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">ret</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">cancel</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">tid</span><span class="p">);</span>
            <span class="nx">_reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">canceled</span><span class="dl">"</span><span class="p">));</span>
        <span class="p">},</span>
        <span class="na">promise</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">tid</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
            <span class="nx">_reject</span> <span class="o">=</span> <span class="nx">reject</span><span class="p">;</span>
        <span class="p">})</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">cancelable</span> <span class="o">=</span> <span class="nx">cancelableSleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="nx">cancelable</span><span class="p">.</span><span class="nx">promise</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">finish</span><span class="dl">"</span><span class="p">);</span> <span class="p">})</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">});</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">cancelable</span><span class="p">.</span><span class="nx">cancel</span><span class="p">();</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">cancel</span><span class="dl">"</span><span class="p">);</span> <span class="p">},</span> <span class="mi">1500</span><span class="p">);</span>
</pre></div></div>

<p>このように <code>{ promise: Promise&lt;T&gt;, cancel: () =&gt; void }</code> という型を <code>CancelablePromise&lt;T&gt;</code> と名付ける。<br>
そして <code>cancel()</code> を呼ぶと <code>reject(new Error("canceled"))</code> されるように関数を作れば良い。</p>

<p>JSではキャンセル可能な非同期APIは比較的珍しいのであまり使うことはないかもしれない( <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/abort" rel="nofollow noopener" target="_blank">XMLHttpRequest.abort()</a> とか？ )</p>

<h2>
<span id="逐次実行中の-cancelable-promise-をキャンセルする" class="fragment"></span><a href="#%E9%80%90%E6%AC%A1%E5%AE%9F%E8%A1%8C%E4%B8%AD%E3%81%AE-cancelable-promise-%E3%82%92%E3%82%AD%E3%83%A3%E3%83%B3%E3%82%BB%E3%83%AB%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>逐次実行中の Cancelable Promise をキャンセルする</h2>

<p><code>CancelablePromise&lt;T&gt;</code> を定義したので <code>reduce</code> でこれを逐次実行してみよう。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">runCancelableAsyncSerialTasks</span><span class="p">(</span><span class="nx">tasks</span><span class="p">:</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">CancelablePromise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">)[]):</span> <span class="nx">CancelablePromise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">ret</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">cancel</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="mi">0</span><span class="p">,</span>
        <span class="na">promise</span><span class="p">:</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">prm</span><span class="p">,</span> <span class="nx">task</span><span class="p">)</span> <span class="o">=&gt;</span>
            <span class="nx">prm</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">task</span><span class="p">)</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(({</span> <span class="nx">promise</span><span class="p">,</span> <span class="nx">cancel</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
                    <span class="nx">ret</span><span class="p">.</span><span class="nx">cancel</span> <span class="o">=</span> <span class="nx">cancel</span><span class="p">;</span>
                    <span class="k">return</span> <span class="nx">promise</span><span class="p">;</span>
                <span class="p">}),</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">void</span> <span class="mi">0</span><span class="p">)),</span>

    <span class="p">};</span> 
    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">cancelable</span> <span class="o">=</span> <span class="nx">runCancelableAsyncSerialTasks</span><span class="p">([</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">),</span> <span class="nx">cancelableSleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">),</span> <span class="nx">cancelableSleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">c</span><span class="dl">"</span><span class="p">),</span> <span class="nx">cancelableSleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)),</span>
<span class="p">]);</span>

<span class="nx">cancelable</span><span class="p">.</span><span class="nx">promise</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">finish</span><span class="dl">"</span><span class="p">);</span> <span class="p">})</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="p">});</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">cancelable</span><span class="p">.</span><span class="nx">cancel</span><span class="p">();</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">cancel</span><span class="dl">"</span><span class="p">);</span> <span class="p">},</span> <span class="mi">1500</span><span class="p">);</span>
</pre></div></div>

<p>出力</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre>a
b
cancel
Error: canceled
    at Object.cancel (&lt;anonymous&gt;:7:21)
    at &lt;anonymous&gt;:39:37
</pre></div></div>

<p>今度は文字を表示してから sleep するようにしたので <code>b</code> が表示された後の sleep がキャンセルされている。</p>

<h2>
<span id="その他-tips" class="fragment"></span><a href="#%E3%81%9D%E3%81%AE%E4%BB%96-tips"><i class="fa fa-link"></i></a>その他 Tips</h2>

<h3>
<span id="ecmascript-ではイベントループや-settimeout-は定義されていない" class="fragment"></span><a href="#ecmascript-%E3%81%A7%E3%81%AF%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%AB%E3%83%BC%E3%83%97%E3%82%84-settimeout-%E3%81%AF%E5%AE%9A%E7%BE%A9%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>ECMAScript ではイベントループや setTimeout は定義されていない</h3>

<ul>
<li>そのため setTimeout は ECMAScript 仕様外である</li>
<li>実際 Java の JS 処理系である Rhino はイベントループはなく当然 setTimeout もない</li>
<li>イベントループおよび setTimeout の仕様は <a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" rel="nofollow noopener" target="_blank">HTML</a> と <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="nofollow noopener" target="_blank">node.js</a> でそれぞれ別に定義されている</li>
<li>にも関わらず Promise は ECMAScript2015 で定義されている。わけがわからないよ</li>
</ul>

<h3>
<span id="promise-の引数関数は同期的に実行される" class="fragment"></span><a href="#promise-%E3%81%AE%E5%BC%95%E6%95%B0%E9%96%A2%E6%95%B0%E3%81%AF%E5%90%8C%E6%9C%9F%E7%9A%84%E3%81%AB%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%82%8B"><i class="fa fa-link"></i></a>Promise の引数関数は同期的に実行される</h3>

<p>上述の通り Promise とイベントループは仕様上は直接関係がないので</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span>
<span class="k">new</span> <span class="nb">Promise</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">c</span><span class="dl">"</span><span class="p">);</span>
</pre></div></div>

<p>は <code>a</code>, <code>b</code>, <code>c</code> の順番に同期的に実行される</p>

<h2>
<span id="async-await-と-yield-と-promise-と-callback-の違い" class="fragment"></span><a href="#async-await-%E3%81%A8-yield-%E3%81%A8-promise-%E3%81%A8-callback-%E3%81%AE%E9%81%95%E3%81%84"><i class="fa fa-link"></i></a>async-await と yield と Promise と callback の違い</h2>

<ul>
<li>
<a href="http://qiita.com/DUxCA/items/77a36b7d2b75d8278f9d" id="reference-92ce76d53e9d62f1a23f">ES2016におけるasyncとgenerator、Promise、CPSの関係</a> を参照</li>
</ul>

<h2>
<span id="promise-の-all-と-race-の使いかた" class="fragment"></span><a href="#promise-%E3%81%AE-all-%E3%81%A8-race-%E3%81%AE%E4%BD%BF%E3%81%84%E3%81%8B%E3%81%9F"><i class="fa fa-link"></i></a>Promise の all と race の使いかた</h2>

<ul>
<li>
<a href="http://qiita.com/Kuniwak/items/9ea447598b7652db78b9" id="reference-95671e620a27f836a529">Promise の all と race だけで書ける待ち合わせ、書けない待ち合わせ</a> を参照</li>
</ul>

<h2>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h2>

<ul>
<li>Promise の中で throw しない</li>
<li>Promise には必ず reject する条件も書く</li>
<li>可変長の非同期逐次処理は <code>reduce</code> を使うことでうまく制御できる</li>
<li>reduce の中の処理を文脈の必要に応じて変えることでリトライやキャンセル可能な非同期逐次処理が作れる</li>
<li>ブラウザ JavaScript や node.js のイベントループは ECMAScript 仕様外だが Promise は仕様内である</li>
</ul>
